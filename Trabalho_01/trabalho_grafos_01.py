# -*- coding: utf-8 -*-
"""Trabalho Grafos 01

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ExxjferHSfbQoUDkrFRh2fgMTakIBbli

<h1><CENTER> GRAFOS 2020/01</h1><h3><center> TRABALHO 01</CENTER></H3>
<H4>DUPLA:<BR>

>LEONARDO FRONZA</t><BR>
RODRIGO FERNANDES</H4>

<h1>Questão 1</h1>
<h3>Busca em profundidade:</h3> 
<ul>
<li>Tem como objetivo visitrar todos os vértices numerando-os nas ordem  que são descobertos, a qual é criado uma pilha e depois vai desempilhando.
	<li>Destaque do vértice da fronteira: Inicia no nó raiz, aqual percorre todos seus ramos possíveis e quando chegar, começa a retroceder.
	<li>Como ela se comporta: O processo inicia com um nó raiz como não visitado e seu vertice inicia com a cor Branca, quando vertice é visitado é alterada sua cor para Cinza, e caso o vertice já tenha sido visitado anteriormente é alterado para a cor preta.
	<li>Qual seu desempenho: Ele percorre o nó raiz até encontrar seu objetivo. Caso não encontre ele inicia uma nova busca a partir de outro vertice não iniciado.
</ul>
	
<h3>Busca em largura:</h3>	
<ul>
	<li>Destaque do vértice da fronteira: É utilizado para encontrar o caminho mais curto, a qual considera a quantidade de saltos necessários minímos para alcançar outro vértice do grafo.
	<li>Como ela se comporta:  O algoritmo calcula a distância (cujo possui o menor número de arestas) desde o vertice raiz até todos os vértices acessíveis.
	<li>Qual seu desempenho: ótimo se custo caminho não diminui com a profundidade
	</ul>
<h3>Busca por custo uniforme:</h3>
<ul>
	<li>Destaque do vértice da fronteira: Expande sempre o nó de menor custo de caminho. Se o custo de todos os passos for o mesmo, o algoritmo acaba sendo o mesmo que a busca em largura
	<li>como ela se comporta: Leva em conta apenas o fator de altura g(n), escolhendo o nó com o menor g a cada passo.
	<li>Qual seu desempenho: Sempre leva em conta o menor custo de se chegar ao nó desejado.
	</ul>
<h3>Busca em aprofundamentoiterativo:</h3>
<ul>
	<li>Destaque do vértice da fronteira: Consiste em uma busca em profundidade onde o limite de profundidade é incrementado gradualmente.
	<li>Como ela se comporta: Combina os benefícios da busca em largura com os benefícios da busca em profundidade. Cria menos estados que a busca em largura e consome menos memória.
	<li>Qual seu desempenho: Ela melhora no custo de memória, porém piora o tempo de busca.
	</ul>
<h3>Busca heurística gulosa (pelo melhor primeiro):</h3>
<ul>
	<li>Destaque do vértice da fronteira: 
	<li>Como ela se comporta: Expande os nós que se encontram mais próximos do objetivo (uma linha reta conectando os dois pontos no caso de distancias), desta maneira é provável que a busca encontre uma solução rapidamente. A implementação do algoritmo se assemelha ao utilizado na busca cega, entretanto utiliza-se uma função heurística para decidir qual o nó deve ser expandido.
	<li>Qual seu desempenho: Ela não é com pleta, pois Pode entrar em loop se não detectar a expansão de estados repetidos. Pode tentar desenvolver um caminho infinito
	</ul>
	
<h3>Busca A*:</h3>
<ul>
	<li>Destaque do vértice da fronteira: Combina o custo do caminho g(n) com o valor da heurística h(n). É a técnica de busca mais utilizada.
	<li>Como ela se comporta: Exponencial com o comprimento da solução, porém boas funções heurísticas diminuem significativamente esse custo. a busca A* degenera para a busca em amplitude quando a heurística não aponta preferência por nenhum caminho ao longo da busca.
	<li>Qual seu desempenho: Custo memória: Guarda todos os nós expandidos na memória
	</ul>

<h1>Questão 2</h1>
"""

#
# @author Leonardo Fronza e Rodrigo Fernandes
#

import sys
from time import time

class Graph:
    edges = {}
    n_vertexes = 0

    def __init__(self, n_vertexes, use_matrix):
        self.n_vertexes = n_vertexes
        if use_matrix:
            self.vertexes = []
            for i in range(n_vertexes):
                self.vertexes.append([])
                for k in range(n_vertexes):
                    self.vertexes[i - 1].append(0)

    def add_undirected_edge(self, v1, v2):
        if v1 in self.edges:
            if not v2 in self.edges[v1]:
                self.edges[v1].append(v2)
        else:
            self.edges[v1] = [v2]
        if v2 in self.edges:
            if not v1 in self.edges[v2]:
                self.edges[v2].append(v1)
        else:
            self.edges[v2] = [v1]

    def qt_undirected_edges(self):
        qt_edges = 0
        for e in self.edges.values():
            qt_edges += len(e)
        return int(qt_edges / 2)

    def undirected_degree_sequence(self):
        degrees = {}
        for k in self.edges.keys():
            if not k in degrees:
                degrees[k] = 0
            for e in self.edges[k]:
                degrees[k] += 1
                if e in degrees:
                    degrees[e] += 1
                else:
                    degrees[e] = 1
        degree_sequence = list(degrees.values())
        degree_sequence += [0] * (self.n_vertexes - len(degree_sequence))
        degree_sequence.sort()
        degree_sequence.reverse()
        degrees = [int(x/2) for x in degree_sequence]
        return degrees

    def print_adjacent_matrix(self):
        matrix = []
        for i in range(self.n_vertexes):
            e = []
            for k in range(self.n_vertexes):
                e.append(-1)
            matrix.append(e)

        for k in self.edges.keys():
            for e in self.edges[k]:
                matrix[k-1][e-1] = 1

        for vertex_edges in matrix:
            for edge in vertex_edges:
                print("{} ".format(edge), end="")
            print("")

    def print_adjacent_vector(self):
        for i in range(1, self.n_vertexes + 1):
            if i in self.edges:
                print("{}: {}".format(i, ", ".join(map(str, self.edges[i]))))
            else:
                print("{}: ".format(i))

    def dfs(self, beginning_vertex):
        dfs_file = open("profundidade.txt", "w")
        traversed = [False] * self.n_vertexes

        def internal_dfs(traversed_array, first_vertex, parent, level):
            v = first_vertex
            traversed_array[v - 1] = True
            dfs_file.write("Vértice: {}; Pai: {}; Profundidade: {}.\n".format(first_vertex, parent, level))
            if v in self.edges:
                for e in self.edges[v]:
                    if not traversed_array[e - 1]:
                        internal_dfs(traversed_array, e, v, level + 1)

        internal_dfs(traversed, beginning_vertex, "-", 0)
        dfs_file.close()

    def iterative_dfs(self, beginning_vertex):
        dfs_file = open("profundidade.txt", "w")
        traversed = [False] * self.n_vertexes
        profundidade = [0] * self.n_vertexes
        pais = [-1] * self.n_vertexes
        pais[beginning_vertex - 1] = "-"
        q = [beginning_vertex]
        while len(q) > 0:
            v = q.pop()
            if not traversed[v - 1]:
                dfs_file.write("Vértice: {}; Pai: {}; Profundidade: {}.\n".format(v, pais[v - 1], profundidade[v - 1]))
                traversed[v - 1] = True
            if v in self.edges:
                for e in self.edges[v]:
                    if not traversed[e - 1]:
                        q.append(e)
                        pais[e - 1] = v
                        profundidade[e - 1] = profundidade[v - 1] + 1
        dfs_file.close()

    def bfs(self, beginning_vertex):
        bfs_file = open("largura.txt", "w")
        traversed = [False] * self.n_vertexes
        stack = [[beginning_vertex, 0]]
        traversed[beginning_vertex - 1] = True
        bfs_file.write("Vértice: {}; Pai: {}; Profundidade: {}.\n".format(beginning_vertex, "-", 0))

        while len(stack) > 0:
            v1, depth = stack.pop(0)
            if v1 in self.edges:
                for e in self.edges[v1]:
                    if not traversed[e - 1]:
                        traversed[e - 1] = True
                        bfs_file.write("Vértice: {}; Pai: {}; Profundidade: {}.\n".format(e, v1, depth + 1))
                        stack.append([e, depth + 1])
        bfs_file.close()

def ler_teste(arquivo):
  if len(sys.argv) == 1:
    print("Favor informar o nome do arquivo a ser processado")
    return
  file_name = arquivo
  try:
    f = open(file_name, "r")
  except:
    print("Não foi possível ler o arquivo informado")
    return
  try:
    output_file = open("saida.txt", "w")
  except:
    print("Não foi possível criar o arquivo saida.txt")
    return
  g = Graph(int(f.readline()), False)
  n_vertexes_str = "Número de vértices: {}\n".format(g.n_vertexes)
  output_file.write(n_vertexes_str)
  for line in f.readlines():
    v1, v2 = line.split()
    v1 = int(v1)
    v2 = int(v2)
    g.add_undirected_edge(v1, v2)
  n_edges_str = "Número de arestas: {}\n".format(g.qt_undirected_edges())
  output_file.write(n_edges_str)
  degree_sequence_str = "Sequência de grau: {}\n".format(', '.join(map(str, g.undirected_degree_sequence())))
  output_file.write(degree_sequence_str)
  print("\nNúmero de vértices, número de arestas e sequência de grau armazenados no arquivo saida.txt\n")
  answer = input("Digite:\n\n1 - Para imprimir a matriz de adjacência.\n2 - Para o vetor de adjacência.\n3 - Para pular etapa.\n\nOpção: ")
  if answer == "1":
    g.print_adjacent_matrix()
  elif answer == "2":
    g.print_adjacent_vector()
  elif answer != "3":
    print("\nResposta inválida, saindo.\n")
    f.close()
    output_file.close()
    sys.exit(0)
  answer = int(input("\nInforme o vértice inicial para que sejam feitas as buscas em profundidade e em largura que serão salvas nos arquivos profundidade.txt e largura.txt. Vértice: "))
  if answer > g.n_vertexes:
    print("Vértice inválido, saindo.")
    f.close()
    output_file.close()
    return
  else:
    t0 = time()
    g.iterative_dfs(answer)
    t1 = time()
    print("Busca em profundidade levou {} segundos".format(t1 - t0))
    t0 = time()
    g.bfs(answer)
    t1 = time()
    print("Busca em largura levou {} segundos".format(t1 - t0))
  f.close()
  output_file.close()

def app():
  answ = input("Digite:\n\n1 - Para abrir teste.txt\n2 - Para abrir teste1.txt\n3 - Para abrir teste2.txt\n\nOpção: ")
  if answ == "1":
    ler_teste("teste.txt")
  elif answ == "2":
    ler_teste("teste1.txt")
  elif answ == "3":
    ler_teste("teste2.txt")
  elif answ != "3":
    print("\nResposta inválida, saindo.\n")
app()

"""<center><h1>TABELA</h1></center>

<table>
<tr><td></td><td><b>Memória Matriz</td><td><b>Memória Lista</td><td><b>T1</td><td><b>T2</td><td><b>T3</td><td><b>T4</td><td><b>T5</td><td><b>T6</td><td><b>T7</td><td><b>T8</td><td><b>T9</td><td><b>T10</td><td><b>Média</td></tr>

<tr><td><b>teste1.txt<br>BFS</td><td>out of memory</td><td>28 MB</td><td>v 1<br>t 0.12</td><td>v 10000<br>t 0.11s</td><td>v 5515<br>t 0.12s</td><td>v 18713<br>t 0.18s</td><td>v 30000<br>t 0.12s</td><td>v 27689<br>t 0.12s</td><td>v 31488<br>t 0.12s</td><td>v 758<br>t 0.12s</td><td>v 9076<br>t 0.18s</td><td>v 27564<br>t 0.12s</td><td>t 0.131s</td></tr>

<tr><td><b>teste1.txt<br>DFS</td><td>out of memory</td><td>28 MB</td><td>v 1<br>t 0.10s</td><td>v 10000<br>t 0.10s</td><td>v 5515<br>t 0.10s</td><td>v 18713<br>t 0.09s</td><td>v 30000<br>t 0.10s</td><td>v 27689<br>t 0.10s</td><td>v 31488<br>t 0.09s</td><td>v 758<br>t 0.09s</td><td>v 9076<br>t 0.09s</td><td>v 27564<br>t 0.10s</td><td>t 0.096s</td></tr>

<tr><td><b>teste2.txt<br>BFS</td><td>out of memory</td><td>111 MB</td><td>v 1<br>t 1.35s</td><td>v 10000<br>t 1.40s</td><td>v 5515<br>t 1.21s</td><td>v 18713<br>t 1.21s</td><td>v 30000<br>t 3.23s</td><td>v 27689<br>t 1.10s</td><td>v 31488<br>t 1.19s</td><td>v 758<br>t 1.29s</td><td>v 9076<br>t 1.22s</td><td>v 27564<br>t 1.21s</td><td>t 1.441s</td></tr>

<tr><td><b>teste2.txt<br>DFS</td><td>out of memory</td><td>111 MB</td><td>v 1<br>t 3.85s</td><td>v 10000<br>t 4.05s</td><td>v 5515<br>t 3.99s</td><td>v 18713<br>t 4.03s</td><td>v 30000<br>t 4.01s</td><td>v 27689<br>t 3.93s</td><td>v 31488<br>t 4.09s</td><td>v 758<br>t 4.00s</td><td>v 9076<br>t 4.01s</td><td>v 27564<br>t 3.91s</td><td>t 3.987s</td></tr>
</table>

<h5>Legenda:</h5>

> <h7>v = vértice<br>t = tempo
</h7>

<h1>Questão 3</h1>
"""

#
# @author Leonardo Fronza e Rodrigo Fernandes
#

class FCustoCidade:
    
    # Construtor
    def __init__(self, id, dist_reta):
        self.id = id
        self.dist_reta = dist_reta
        self.cidVizinha = {}
        self.pai = None
        self.dist_origem = 999

    # Distancia Para
    def dist_para(self, cidade):
        return self.cidVizinha[cidade.id][1]

    # Adiciona cidade vivinha
    def addCidadeVizinha(self, cidade, distancia):
        if not cidade.id in self.cidVizinha:
            self.cidVizinha[cidade.id] = (cidade, distancia)
            cidade.cidVizinha[self.id] = (self, distancia)

    # Distancia ate o pai
    def dist_ate_pai(self):
        if self.pai == None:
            return 0
        else:
            return self.pai.dist_origem + self.pai.dist_para(self)

    # Executa a busca das cidades
    def ExecutaBusca(self, cidDestino):
        self.dist_origem = 0
        caminho = [self]
        
        # Enquanto o caminho for amior que zero continua a busca pela cidade
        while len(caminho) > 0:
            distMenoCidade = None

            # Vamos percorrer as cidades com base nos caminho e encontrar a cidade com menor distancia
            for cidade in caminho:
                # Se a distancia do cidade pai + distancia da reta da cidade for menor que a distancia do pai + menor ditancia entao adiconamos a cidade
                if distMenoCidade == None or ((cidade.dist_ate_pai() + cidade.dist_reta) < (distMenoCidade.dist_ate_pai() + distMenoCidade.dist_reta)):
                    distMenoCidade = cidade

            # Apresenta a cidade com menor distancia
            print(f"Pegou a cidade {distMenoCidade.id}")

            if distMenoCidade == cidDestino:
                return cidDestino

            caminho.remove(distMenoCidade)

            cidVizinha = [c[0] for c in distMenoCidade.cidVizinha.values()]

            # Vamos percorrer a cidade ate a cidade vizinha
            for cidade in cidVizinha:
                if cidade != self and cidade.pai == None or ((distMenoCidade.dist_origem + distMenoCidade.dist_para(cidade)) < cidade.dist_ate_pai()):
                    cidade.dist_origem = distMenoCidade.dist_origem + distMenoCidade.dist_para(cidade)
                    cidade.pai = distMenoCidade
                    if not cidade in caminho:
                        print(f"Incluiu {cidade.id}")
                        print(f"Dist. origem: {cidade.dist_origem}")
                        print(f"Dist. pai {cidade.pai.id} até aqui: {cidade.pai.dist_para(cidade)}")
                        print(f"Função de Custo: {cidade.dist_origem + cidade.dist_reta}\n")
                        
                        caminho.append(cidade)
                    else:
                        print(f"Modificou a distancia origem de {cidade.id} para: {cidade.dist_origem}")
                        print(f"Função de Custo: {cidade.dist_origem + cidade.dist_reta}\n")

        return None

# Adiciona a funcao de custo de cada cidade
A = FCustoCidade('A', 230)
B = FCustoCidade('B', 182)
C = FCustoCidade('C', 179)
D = FCustoCidade('D', 165)
E = FCustoCidade('E', 166)
F = FCustoCidade('F', 160)
G = FCustoCidade('G', 155)
H = FCustoCidade('H', 137)
I = FCustoCidade('I', 117)
J = FCustoCidade('J', 115)
K = FCustoCidade('K', 113)
L = FCustoCidade('L', 100)
M = FCustoCidade('M', 97)
N = FCustoCidade('N', 73)
O = FCustoCidade('O', 70)
P = FCustoCidade('P', 61)
Q = FCustoCidade('Q', 61)
R = FCustoCidade('R', 0)

# Adicona as cidades vizinhas pertencentes ao vertice
A.addCidadeVizinha(B, 73)
A.addCidadeVizinha(C, 64)
A.addCidadeVizinha(D, 89)
A.addCidadeVizinha(E, 104)
B.addCidadeVizinha(K, 83)
C.addCidadeVizinha(I, 64)
D.addCidadeVizinha(N, 89)
E.addCidadeVizinha(J, 40)
F.addCidadeVizinha(I, 31)
F.addCidadeVizinha(N, 84)
G.addCidadeVizinha(J, 35)
G.addCidadeVizinha(Q, 113)
H.addCidadeVizinha(K, 35)
H.addCidadeVizinha(L, 36)
I.addCidadeVizinha(L, 28)
I.addCidadeVizinha(M, 20)
J.addCidadeVizinha(N, 53)
J.addCidadeVizinha(Q, 80)
L.addCidadeVizinha(P, 63)
M.addCidadeVizinha(O, 50)
O.addCidadeVizinha(P, 41)
O.addCidadeVizinha(R, 72)
P.addCidadeVizinha(R, 65)
Q.addCidadeVizinha(R, 65)

vertice = A.ExecutaBusca(R)
adjacente = vertice.dist_origem

s = []

# Enquanto o vertice nao eh nulo vai adicionando ao vertice pai
while vertice != None:
    s.append(vertice)
    vertice = vertice.pai

print("\nRota é:\n", end="")

while len(s) > 0:
    if len(s) > 1:
        seta = "-> "
    else:
        seta = "\n"
    print(f"{s.pop().id} {seta}", end="")

print(f"\nDistancia de A ate E eh: {adjacente}")